package com.devinlynch.cachew;

import com.devinlynch.cachew.stubbing.CacheWrapper;
import com.devinlynch.cachew.stubbing.MockCacheInterceptor;
import com.devinlynch.cachew.stubbing.MockCacheOptions;

public class Cachew {
	
	/**
	 * Call this to wrap an object with a caching layer.  The first parameter is the object that you want to
	 * wrap. The second parameter is the class which contains the annotated descriptions.  If the class of the 
	 * object you are wrapping is exactly the same as the class that has your annotations, then use the other 
	 * {@link Cachew#cache(Object)} method.
	 * @param service The object which will be wrapped with a caching layer
	 * @param describedClass The class which contains methods that have caching annotations.  This class <b>MUST</b>
	 * have <b>EVERY</b> method that the service object has. That is, this class must be equal to the service object's
	 * class OR be a subclass of the service object's class OR be an interface which the service object's class
	 * implements however the service object class does not have any other methods than those of the interface.
	 * of 
	 * @return
	 */
	public static<T> T cache(
			T service, 
			Class<?> describedClass) {
		return CacheWrapper.cache(service, describedClass);
	}
	
	/**
	 * Call this to wrap an object with a caching layer.  It is assumed that the class of the object passed will
	 * have the annotations required for caching.
	 * @param service The object which will be wrapped with a caching layer
	 * @return
	 */
	public static<T> T cache(
			T service) {
		return CacheWrapper.cache(service);
	}
	
	/**
	 * Returns a mock object which can be used in conjunction with {@link Cachew#forKeyGeneratedBy(Object)} for
	 * manually interacting with the cache for a value generated by a method.
	 * @param o
	 * @return
	 */
	public static<T> T mock(T o) {
		return MockCacheInterceptor.mockCache(o);
	}
	
	/**
	 * After creating a mock object of the object you want to have values cached for, call this method with the argument
	 * being the return value of calling the mock object's method you want to define functionality for.
	 * <br />
	 * <br />
	 * For example: You can do ' forKeyGeneratedBy( mock( new MyService() ).get( "1234") ); '
	 * <br/>
	 * This will return you back {@link MockCacheOptions} for which you can perform on the cache for the key that would
	 * be generated by calling (new MyService()).get("1234").
	 * @param o
	 * @return
	 */
	public static MockCacheOptions forKeyGeneratedBy(Object o) {
		return new MockCacheOptions();
	}
}


